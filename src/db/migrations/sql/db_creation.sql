drop schema if exists public cascade;
create schema if not exists public;
set schema 'public';
set time zone 'Europe/Belgrade';

create table "Drzava"
(
    "drzavaId"    integer generated always as identity
        constraint "Drzava_pk" primary key,
    "nazivDrzave" varchar(50),
    "pozivniBroj" integer
        constraint unq_drzava_pozivni_broj unique,
    "clanstvoEU"  bool
);

create table "Grad"
(
    "gradId"        integer generated always as identity
        constraint "Grad_pk" primary key,
    "nazivGrada"    varchar(50),
    "postanskiBroj" integer,
    "drzavaId"      integer
        constraint "Grad_Drzava_drzavaId_fk" references "Drzava"
);

create table "Adresa"
(
    "adresaId" integer generated always as identity
        constraint "Adresa_pk" primary key,
    "ulica"    varchar(50),
    "broj"     varchar(50),
    "gradId"   integer
        constraint "Adresa_Grad_gradId_fk" references "Grad"
);

create table "PrivredniSubjekt" (
  "maticniBroj" bigint constraint "PrivredniSubjekt_pk" primary key,
    "pib" bigint not null unique,
    "nazivPrivrednogSubjekta" varchar(50),
    "stranica" varchar(50),
    "adresaId" integer constraint "PrivredniSubjekt_Adresa_adresaId_fk" references "Adresa"
);

create table "Zaposleni" (
  "zaposleniId" integer generated always as identity constraint "Zaposleni_pk" primary key,
    "imeIPrezime" varchar(100),
    "email" varchar(100) unique,
    "sifra" varchar(64),
    "brojTelefona" varchar,
    "datumZaposlenja" date,
    "maticniBroj" bigint constraint "Zaposleni_PrivredniSubjekt_maticniBroj" references "PrivredniSubjekt"
);

create table "Oznaka" (
    "brojOznake" integer generated always as identity constraint "Oznaka_pk" primary key,
    "nazivOznake" varchar(50) unique
);

create table "Valuta" (
    "valutaId" integer generated always as identity constraint "Valuta_pk" primary key,
    "nazivValute" varchar(50),
    "oznakaValute" varchar(5) unique
);

create table "JedinicaMere" (
    "jedinicaMereId" integer generated always as identity constraint "JedinicaMere_pk" primary key,
    "nazivJediniceMere" varchar,
    "oznakaJediniceMere" varchar(5) unique
);

-- distinct tip
create type price_type as (
   iznos numeric(20,2)
);


CREATE FUNCTION price_type_to_numeric(p price_type) RETURNS NUMERIC(20,2) AS
$$
   SELECT $1.iznos;
$$ LANGUAGE SQL;


CREATE FUNCTION numeric_to_cena_type(p NUMERIC(20,2)) RETURNS price_type AS
$$
   SELECT ROW($1::NUMERIC(20,2));
$$ LANGUAGE SQL;

-- struktuirani tip
create type dates as (
    "datumIzdavanja" timestamptz,
    "datumZatvaranja" timestamptz
);

CREATE OR REPLACE FUNCTION timeSinceStart(jp dates)
RETURNS interval AS $$
BEGIN
   RETURN AGE(now(), jp."datumIzdavanja");
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION timeUntilEnd(jp dates)
RETURNS interval AS $$
BEGIN
   RETURN AGE(jp."datumZatvaranja", now());
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION plannedDuration(jp dates)
RETURNS interval AS $$
BEGIN
   RETURN AGE(jp."datumZatvaranja", jp."datumIzdavanja");
END;
$$ LANGUAGE plpgsql;


create table "JavniPoziv" (
    "referentniBrojJP" integer generated always as identity constraint "JavniPoziv_pk" primary key,
    "nazivPoziva" varchar(100) not null,
    "datumi" dates not null,
    "procenjenaVrednost" price_type not null,
--     denormalizacija 3nf
    "oznakaValute" varchar(5) not null,
    "oznakaId" integer constraint "JavniPoziv_Oznaka_fk" references "Oznaka" not null,
    "valutaId" integer constraint "JavniPoziv_Valuta_fk" references "Valuta" not null,
    "zaposleniId" integer constraint "JavniPoziv_Zaposleni_fk" references "Zaposleni" not null
);

create index ind_dates on public."JavniPoziv"(datumi);

create table "JavniPozivDetalji" (
    "referentniBrojJPD" integer generated by default as identity constraint "JavniPozivDetalji_pk" primary key,
    "opis" text not null,
    "dodatniPodaci" text,
    "dozvoljeneVarijante" bool not null,
    "adresaDostavljanja" varchar(50) not null,
    "podlozanProduzenju" bool not null,
    "obrazlozenjeProduzenja" text,
    "osnovnaDelatnost" varchar(100) not null ,
    constraint "osnovnaDelatnost_check" check ("osnovnaDelatnost" in ('Elektricna energija', 'Poljoprivreda'))
);

-- view za horizontalno particionisanje

create or replace view view_javni_poziv as
select jp."referentniBrojJP", "nazivPoziva", datumi, "procenjenaVrednost", "oznakaValute", "oznakaId", "valutaId", "zaposleniId", jpd.opis, "dodatniPodaci", "dozvoljeneVarijante", "adresaDostavljanja", "podlozanProduzenju", "obrazlozenjeProduzenja", "osnovnaDelatnost"
from "JavniPoziv" jp
inner join "JavniPozivDetalji" as jpd on jp."referentniBrojJP" = jpd."referentniBrojJPD";

-- triger za insert
create or replace function insert_javni_poziv_all_func()
returns trigger as $$
    begin
        insert into "JavniPoziv" ("nazivPoziva", datumi, "procenjenaVrednost", "oznakaValute", "oznakaId", "valutaId", "zaposleniId")
        values (new."nazivPoziva", new."datumi", new."procenjenaVrednost", new."oznakaValute", new."oznakaId", new."valutaId", new."zaposleniId");
        select "referentniBrojJP" from "JavniPoziv" order by "referentniBrojJP" desc limit 1 into new."referentniBrojJP";
        insert into "JavniPozivDetalji" ("referentniBrojJPD", "opis", "dodatniPodaci", "dozvoljeneVarijante", "adresaDostavljanja", "podlozanProduzenju", "obrazlozenjeProduzenja", "osnovnaDelatnost")
        values (new."referentniBrojJP", new."opis", new."dodatniPodaci", new."dozvoljeneVarijante", new."adresaDostavljanja", new."podlozanProduzenju", new."obrazlozenjeProduzenja", new."osnovnaDelatnost");

        return new;
    end;
$$ language plpgsql;

create trigger insert_javni_poziv_all
instead of insert on "view_javni_poziv"
for each row
execute function insert_javni_poziv_all_func();

-- triger za 3nf
CREATE OR REPLACE FUNCTION update_oznaka_valute_javni_poziv()
RETURNS TRIGGER AS $$
BEGIN

 SELECT "oznakaValute" INTO NEW."oznakaValute"
 FROM "Valuta"
 WHERE "valutaId" = NEW."valutaId";

 RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_oznaka_valute_javni_poziv_trigger
BEFORE INSERT ON "JavniPoziv"
FOR EACH ROW
EXECUTE FUNCTION update_oznaka_valute_javni_poziv();


CREATE OR REPLACE FUNCTION prevent_direct_oznaka_valute_javni_poziv_change()
RETURNS TRIGGER AS $$
BEGIN
 IF OLD."oznakaValute" IS DISTINCT FROM NEW."oznakaValute" THEN
   RAISE EXCEPTION 'Direktna izmena kolone oznakaValute u tabeli JavniPoziv nije dozvoljena.';
 END IF;
 RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER prevent_direct_oznaka_valute_javni_poziv_change_trigger
BEFORE UPDATE ON "JavniPoziv"
FOR EACH ROW
WHEN ( pg_trigger_depth() < 1 )
EXECUTE FUNCTION prevent_direct_oznaka_valute_javni_poziv_change();


CREATE OR REPLACE FUNCTION update_javni_poziv_oznaka_valute()
RETURNS TRIGGER AS $$
BEGIN
 IF OLD."oznakaValute" IS DISTINCT FROM NEW."oznakaValute" THEN
   UPDATE "JavniPoziv"
   SET "oznakaValute" = NEW."oznakaValute"
   WHERE "valutaId" = NEW."valutaId";
 END IF;
 RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_javni_poziv_naziv_trigger
AFTER UPDATE ON "Valuta"
FOR EACH ROW
EXECUTE FUNCTION update_javni_poziv_oznaka_valute();

create table "KriterijumPoziva" (
    "kriterijumPozivaId" integer generated always as identity constraint "KriterijumPoziva_pk" primary key,
    "nazivKriterijumaPoziva" varchar(100),
    "referentniBrojJP" integer constraint "KriterijumPoziva_JavniPoziv_fk" references "JavniPoziv"
);


create table "Ponuda" (
    "referentniBrojPonude" integer generated always as identity constraint "Ponuda_pk" primary key,
    datum timestamptz not null,
    "ukljucujeProizvodjace" bool not null,
    "samostalna" bool not null,
    "izjavaOIntegritetu" bool not null,
    "cenaBezPDV" price_type not null,
    "cenaSaPDV" price_type not null,
    "valutaId" integer not null constraint "Ponuda_Valuta_fk" references "Valuta",
    "referentniBrojJP" integer not null constraint "Ponuda_JavniPoziv_fk" references "JavniPoziv",
    "zaposleniId" integer not null constraint "Ponuda_Zaposleni_fk" references "Zaposleni"
);

create index refBrojJP_ind on "Ponuda"("referentniBrojJP");

create table "PonudaKriterijuma" (
    "referentniBrojPonude" integer not null constraint "PonudaKriterijuma_Ponuda_fk" references "Ponuda",
    "kriterijumPozivaId" integer not null constraint "PonudaKriterijuma_KriterijumPoziva_fk" references "KriterijumPoziva",
    "jedinicaMereId" integer not null constraint "PonudaKriterijuma_JedinicaMere_fk" references "JedinicaMere",
    "vrednost" numeric(20,2) not null,
--     denormalizacija 2nf
    "nazivKriterijumaPoziva" varchar(100) not null,
    primary key ("referentniBrojPonude", "kriterijumPozivaId")
);

create table "DostavljeniDokument" (
    "dokumentId" integer generated always as identity constraint "DostavljeniDokument_pk" primary key,
    "nazivDokumenta" varchar(50),
    "velicina" integer,
    "poverljiv" bool,
    "obrazlozenjePoverljivosti" text,
    "adresa" varchar(50),
    "referentniBrojPonude" integer constraint "DostavljeniDokument_Ponuda_fk" references "Ponuda"
);

-- trigeri za denormalizaciju 2nf
CREATE OR REPLACE FUNCTION update_naziv_ponuda_kriterijuma()
RETURNS TRIGGER AS $$
BEGIN

 SELECT "nazivKriterijumaPoziva" INTO NEW."nazivKriterijumaPoziva"
 FROM "KriterijumPoziva"
 WHERE "kriterijumPozivaId" = NEW."kriterijumPozivaId";

 RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_naziv_ponuda_kriterijuma_trigger
BEFORE INSERT ON "PonudaKriterijuma"
FOR EACH ROW
EXECUTE FUNCTION update_naziv_ponuda_kriterijuma();


CREATE OR REPLACE FUNCTION prevent_direct_naziv_ponuda_kriterijuma_change()
RETURNS TRIGGER AS $$
BEGIN
 IF OLD."nazivKriterijumaPoziva" IS DISTINCT FROM NEW."nazivKriterijumaPoziva" THEN
   RAISE EXCEPTION 'Direktna izmena kolone naziv u tabeli PonudaKriterijuma nije dozvoljena.';
 END IF;
 RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_direct_naziv_ponuda_kriterijuma_change_trigger
BEFORE UPDATE ON "PonudaKriterijuma"
FOR EACH ROW
WHEN ( pg_trigger_depth() < 1 )
EXECUTE FUNCTION prevent_direct_naziv_ponuda_kriterijuma_change();

CREATE OR REPLACE FUNCTION update_ponuda_kriterijuma_naziv()
RETURNS TRIGGER AS $$
BEGIN
 IF OLD."nazivKriterijumaPoziva" IS DISTINCT FROM NEW."nazivKriterijumaPoziva" THEN
   UPDATE "PonudaKriterijuma"
   SET "nazivKriterijumaPoziva" = NEW."nazivKriterijumaPoziva"
   WHERE "kriterijumPozivaId" = NEW."kriterijumPozivaId";
 END IF;
 RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_ponuda_kriterijuma_naziv_trigger
AFTER UPDATE ON "KriterijumPoziva"
FOR EACH ROW
EXECUTE FUNCTION update_ponuda_kriterijuma_naziv();

create table "ZapisnikPonuda" (
    "referentniBrojZP" integer generated always as identity constraint "ZapisnikPonuda_pk" primary key,
    "datumKreiranja" date
);

create table "PonudaZapisnikPonuda" (
    "referentniBrojPonude" integer constraint "PonudaZapisnikPonuda_Ponuda_fk" references "Ponuda",
    "referentniBrojZP" integer constraint "PonudaZapisnikPonuda_ZapisnikPonuda_fk"  references "ZapisnikPonuda",
    primary key ("referentniBrojPonude")
);

create table "OdlukaODodeliUgovora" (
    "odlukaODodeliUgovoraId" integer generated always as identity constraint "OdlukaODodeliUgovora_pk" primary key,
    "datumOdluke" date,
    "komisijaPrviClan" integer constraint "Odluka_prvi_clan_Zaposleni_fk" references "Zaposleni" ("zaposleniId"),
    "komisijaDrugiClan" integer constraint "Odluka_drugi_clan_Zaposleni_fk" references "Zaposleni" ("zaposleniId"),
    "komisijaTreciClan" integer constraint "Odluka_treci_clan_Zaposleni_fk" references "Zaposleni" ("zaposleniId"),
    "referentniBrojJP" integer constraint "OdlukaODodeliUgovora_JavniPoziv_fk" references "JavniPoziv",
    "referentniBrojPonude" integer constraint "OdlukaODodeliUgovora_Ponuda_fk" references "Ponuda"
);

create table "TipUgovora" (
    "tipUgovoraId" integer generated always as identity constraint "TipUgovora_pk" primary key,
    "nazivTipa" varchar(50) unique
);

create table "Ugovor" (
    "referentniBrojUgovora" integer generated always as identity,
    "datumPotpisa" date,
    "tipUgovoraId" integer constraint "Ugovor_TipUgovora_fk" references "TipUgovora",
    "odlukaODodeliUgovoraId" integer constraint "Ugovor_OdlukaODodeliUgovora_fk" references "OdlukaODodeliUgovora",
    "potpisnikA" integer constraint "Ugovor_potpisnikA_PrivredniSubjekt_fk" references "PrivredniSubjekt"("maticniBroj"),
    "potpisnikB" integer constraint "Ugovor_potpisnikB_PrivredniSubjekt_fk" references "PrivredniSubjekt"("maticniBroj"),
    constraint "Ugovor_pk" primary key ("referentniBrojUgovora", "datumPotpisa")
) partition by range("datumPotpisa");

create table "Ugovor_2019" partition of "Ugovor"
for values from('2019-01-01') to ('2020-01-01');

create table "Ugovor_2020" partition of "Ugovor"
for values from('2020-01-01') to ('2021-01-01');

create table "Ugovor_2021" partition of "Ugovor"
for values from('2021-01-01') to ('2022-01-01');

create table "Ugovor_2023" partition of "Ugovor"
for values from('2023-01-01') to ('2024-01-01');

create table "Ugovor_2024" partition of "Ugovor"
for values from('2024-01-01') to ('2025-01-01');

create table "Ugovor_2025" partition of "Ugovor"
for values from('2025-01-01') to ('2026-01-01');

create table "ClanUgovora" (
    "clanBroj" integer,
    "referentniBrojUgovora" integer,
    "datumPotpisa" date,
    "naslov" varchar(50),
    "opisClana" text,
    primary key ("clanBroj", "referentniBrojUgovora", "datumPotpisa"),
    foreign key ("referentniBrojUgovora", "datumPotpisa") references "Ugovor" ("referentniBrojUgovora", "datumPotpisa")
);

